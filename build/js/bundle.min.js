'use strict';

var PaintMode;
(function (PaintMode) {
    PaintMode["Blank"] = "blank";
    PaintMode["Start"] = "start";
    PaintMode["End"] = "end";
    PaintMode["Wall"] = "wall";
})(PaintMode || (PaintMode = {}));
var PaintManager = /** @class */ (function () {
    function PaintManager() {
        this.init();
    }
    PaintManager.prototype.init = function () {
        document.addEventListener("keypress", function (e) {
            switch (e.code) {
                case "Digit1":
                    PaintManager.mode = PaintMode.Blank;
                    break;
                case "Digit2":
                    PaintManager.mode = PaintMode.Start;
                    break;
                case "Digit3":
                    PaintManager.mode = PaintMode.End;
                    break;
                case "Digit4":
                    PaintManager.mode = PaintMode.Wall;
                    break;
            }
        });
    };
    PaintManager.mode = PaintMode.Blank;
    return PaintManager;
}());

var NodeType;
(function (NodeType) {
    NodeType["Blank"] = "blank";
    NodeType["Start"] = "start";
    NodeType["End"] = "end";
    NodeType["Wall"] = "wall";
    NodeType["Path"] = "path";
})(NodeType || (NodeType = {}));
var board = document.getElementById("board");
var Node = /** @class */ (function () {
    function Node(type, coordinates) {
        this.type = NodeType.Blank;
        this.type = type;
        this.coordinates = coordinates;
        this.createElement();
        this.createListener();
    }
    Node.prototype.createElement = function () {
        var nodeElement = document.createElement("div");
        nodeElement.classList.add("node");
        nodeElement.classList.add("node-".concat(this.type));
        board.appendChild(nodeElement);
        this.element = nodeElement;
    };
    Node.prototype.createListener = function () {
        var _this = this;
        this.element.addEventListener("click", function () {
            switch (PaintManager.mode) {
                case PaintMode.Blank:
                    _this.updateNodeType(NodeType.Blank);
                    break;
                case PaintMode.Start:
                    NodeManager.setStartNode(_this);
                    _this.updateNodeType(NodeType.Start);
                    break;
                case PaintMode.End:
                    NodeManager.setEndNode(_this);
                    _this.updateNodeType(NodeType.End);
                    break;
                case PaintMode.Wall:
                    _this.updateNodeType(NodeType.Wall);
                    break;
            }
        });
    };
    Node.prototype.updateNodeType = function (type) {
        var oldType = this.type;
        this.type = type;
        // Change the classes to update colour.
        this.element.classList.remove("node-".concat(oldType));
        this.element.classList.add("node-".concat(type));
    };
    Node.prototype.getNeighbours = function () {
        var neighbours = [];
        // Top.
        var top = NodeManager.getNodeByCoordinates({
            x: this.coordinates.x,
            y: this.coordinates.y - 1
        });
        if (top != null && top.type != NodeType.Wall)
            neighbours.push(top);
        // Left.
        var left = NodeManager.getNodeByCoordinates({
            x: this.coordinates.x - 1,
            y: this.coordinates.y
        });
        if (left != null && left.type != NodeType.Wall)
            neighbours.push(left);
        // Right.
        var right = NodeManager.getNodeByCoordinates({
            x: this.coordinates.x + 1,
            y: this.coordinates.y
        });
        if (right != null && right.type != NodeType.Wall)
            neighbours.push(right);
        // Top.
        var bottom = NodeManager.getNodeByCoordinates({
            x: this.coordinates.x,
            y: this.coordinates.y + 1
        });
        if (bottom != null && bottom.type != NodeType.Wall)
            neighbours.push(bottom);
        return neighbours;
    };
    Node.prototype.setParentNode = function (parent) {
        this.parent = parent;
    };
    Node.prototype.getParentNode = function () {
        return this.parent;
    };
    return Node;
}());

var NODE_COUNT = 100;
var NodeManager = /** @class */ (function () {
    function NodeManager() {
        this.generateBoard();
    }
    NodeManager.prototype.generateBoard = function () {
        for (var i = 0; i < NODE_COUNT; i++) {
            // Generate coordinates
            var x = i % 10;
            var y = 10 - Math.floor(i / 10);
            var coords = { x: x, y: y };
            var node = new Node(NodeType.Blank, coords);
            NodeManager.nodes.push(node);
        }
    };
    NodeManager.prototype.resetBoard = function () {
        // Set all nodes to blank.
        NodeManager.nodes.forEach(function (node) {
            node.updateNodeType(NodeType.Blank);
            NodeManager.startNode = null;
            NodeManager.endNode = null;
        });
    };
    NodeManager.setStartNode = function (node) {
        if (this.startNode != null)
            // There is an existing one, so set it blank.
            this.startNode.updateNodeType(NodeType.Blank);
        // Update variable and new start node.
        this.startNode = node;
        node.updateNodeType(NodeType.Start);
    };
    NodeManager.setEndNode = function (node) {
        if (this.endNode != null)
            // There is an existing one, so set it to blank.
            this.endNode.updateNodeType(NodeType.Blank);
        // Update variable and new end node.
        this.endNode = node;
        node.updateNodeType(NodeType.Start);
    };
    NodeManager.getNodeByCoordinates = function (coordinates) {
        var foundNode;
        NodeManager.nodes.forEach(function (node) {
            if (coordinates.x == node.coordinates.x &&
                coordinates.y == node.coordinates.y) {
                foundNode = node;
            }
        });
        return foundNode;
    };
    NodeManager.nodes = [];
    return NodeManager;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function calculateManhattanDistance(start, end) {
    return (Math.abs(start.coordinates.x - end.coordinates.x) +
        Math.abs(start.coordinates.y - end.coordinates.y));
}
function runPathfinding() {
    return __awaiter(this, void 0, void 0, function () {
        var openList, closedList, foundDestination, _loop_1;
        return __generator(this, function (_a) {
            openList = [];
            closedList = [];
            foundDestination = false;
            openList.push(NodeManager.startNode);
            NodeManager.startNode.fCost = 0;
            _loop_1 = function () {
                // Get node with lowest f cost.
                var currentNode;
                openList.forEach(function (node, i) {
                    if (currentNode == null || node.fCost < currentNode.fCost) {
                        currentNode = node;
                        openList.splice(i, 1);
                        closedList.push(currentNode);
                    }
                });
                // Check if found end.
                if (currentNode == NodeManager.endNode) {
                    console.log("FOUND THE GOAL");
                    // Paint path.
                    var currentPathNode_1 = currentNode.getParentNode();
                    var drawPathInterval_1 = setInterval(function () {
                        if (currentPathNode_1.getParentNode() == NodeManager.startNode)
                            clearInterval(drawPathInterval_1);
                        currentPathNode_1.updateNodeType(NodeType.Path);
                        currentPathNode_1 = currentPathNode_1.getParentNode();
                    }, 100);
                    foundDestination = true;
                    return "continue";
                }
                // Get children of current node.
                var children = currentNode.getNeighbours();
                children.forEach(function (node) {
                    if (closedList.includes(node))
                        return;
                    node.setParentNode(currentNode);
                    node.gCost = currentNode.gCost + 10;
                    node.hCost = calculateManhattanDistance(node, NodeManager.endNode);
                    node.fCost = node.gCost + node.hCost;
                    openList.push(node);
                });
            };
            while (!foundDestination) {
                _loop_1();
            }
            return [2 /*return*/];
        });
    });
}

new PaintManager();
var nodeManager = new NodeManager();
var resetButton = document.getElementById("reset-button");
resetButton.addEventListener("click", nodeManager.resetBoard);
var startButton = document.getElementById("start-button");
startButton.addEventListener("click", runPathfinding);
